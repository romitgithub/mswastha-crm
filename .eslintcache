[{"/Users/rivigo/mswasth/crm/src/index.tsx":"1","/Users/rivigo/mswasth/crm/src/reportWebVitals.ts":"2","/Users/rivigo/mswasth/crm/src/router/index.tsx":"3","/Users/rivigo/mswasth/crm/src/App.tsx":"4","/Users/rivigo/mswasth/crm/src/store/index.ts":"5","/Users/rivigo/mswasth/crm/src/store/rootReducer.ts":"6","/Users/rivigo/mswasth/crm/src/containers/login/reducer.ts":"7","/Users/rivigo/mswasth/crm/src/containers/login/actionType.enum.ts":"8","/Users/rivigo/mswasth/crm/src/store/initialState.ts":"9","/Users/rivigo/mswasth/crm/src/containers/login/index.tsx":"10","/Users/rivigo/mswasth/crm/src/containers/login/actions.ts":"11","/Users/rivigo/mswasth/crm/src/containers/Login/reducer.ts":"12","/Users/rivigo/mswasth/crm/src/containers/Login/index.tsx":"13","/Users/rivigo/mswasth/crm/src/containers/Login/actionType.enum.ts":"14","/Users/rivigo/mswasth/crm/src/containers/Login/actions.ts":"15","/Users/rivigo/mswasth/crm/src/containers/PatientRecords/index.tsx":"16","/Users/rivigo/mswasth/crm/src/containers/PatientRecords/actions.ts":"17","/Users/rivigo/mswasth/crm/src/containers/PatientRecords/actionType.enum.ts":"18","/Users/rivigo/mswasth/crm/src/services/data.service.ts":"19","/Users/rivigo/mswasth/crm/src/services/event.service.ts":"20","/Users/rivigo/mswasth/crm/src/services/cookie.service.ts":"21","/Users/rivigo/mswasth/crm/src/config/app.config.ts":"22","/Users/rivigo/mswasth/crm/src/containers/PatientRecords/reducer.ts":"23","/Users/rivigo/mswasth/crm/src/containers/Landing/index.tsx":"24","/Users/rivigo/mswasth/crm/src/components/Header/index.tsx":"25","/Users/rivigo/mswasth/crm/src/components/ProtectedRoute.tsx":"26","/Users/rivigo/mswasth/crm/src/components/Sidebar/index.tsx":"27"},{"size":626,"mtime":1612188064613,"results":"28","hashOfConfig":"29"},{"size":416,"mtime":1612188064627,"results":"30","hashOfConfig":"29"},{"size":611,"mtime":1612370030382,"results":"31","hashOfConfig":"29"},{"size":551,"mtime":1612188064549,"results":"32","hashOfConfig":"29"},{"size":211,"mtime":1612172946421,"results":"33","hashOfConfig":"29"},{"size":273,"mtime":1612358348098,"results":"34","hashOfConfig":"29"},{"size":537,"mtime":1612189829136,"results":"35","hashOfConfig":"29"},{"size":127,"mtime":1612189638147,"results":"36","hashOfConfig":"29"},{"size":388,"mtime":1612363084754,"results":"37","hashOfConfig":"29"},{"size":1602,"mtime":1612237209974,"results":"38","hashOfConfig":"29"},{"size":385,"mtime":1612190492072,"results":"39","hashOfConfig":"29"},{"size":877,"mtime":1612368632889,"results":"40","hashOfConfig":"29"},{"size":2145,"mtime":1612364266455,"results":"41","hashOfConfig":"29"},{"size":191,"mtime":1612357543668,"results":"42","hashOfConfig":"29"},{"size":1259,"mtime":1612364029305,"results":"43","hashOfConfig":"29"},{"size":3069,"mtime":1612372023263,"results":"44","hashOfConfig":"29"},{"size":2458,"mtime":1612357558714,"results":"45","hashOfConfig":"29"},{"size":154,"mtime":1612357541436,"results":"46","hashOfConfig":"29"},{"size":13942,"mtime":1612351792241,"results":"47","hashOfConfig":"29"},{"size":1048,"mtime":1612239093487,"results":"48","hashOfConfig":"29"},{"size":2248,"mtime":1612334022635,"results":"49","hashOfConfig":"29"},{"size":718,"mtime":1612261848878,"results":"50","hashOfConfig":"29"},{"size":512,"mtime":1612357519683,"results":"51","hashOfConfig":"29"},{"size":1912,"mtime":1612373134780,"results":"52","hashOfConfig":"29"},{"size":465,"mtime":1612372304073,"results":"53","hashOfConfig":"29"},{"size":491,"mtime":1612352955542,"results":"54","hashOfConfig":"29"},{"size":380,"mtime":1612370903713,"results":"55","hashOfConfig":"29"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},"mhmjm0",{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"65"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"82","messages":"83","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"88","messages":"89","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"90","messages":"91","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"92","usedDeprecatedRules":"58"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"97","usedDeprecatedRules":"58"},{"filePath":"98","messages":"99","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"102","messages":"103","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"104","messages":"105","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"106","messages":"107","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"108","messages":"109","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"110","messages":"111","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"112","messages":"113","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/rivigo/mswasth/crm/src/index.tsx",[],["114","115"],"/Users/rivigo/mswasth/crm/src/reportWebVitals.ts",[],"/Users/rivigo/mswasth/crm/src/router/index.tsx",[],"/Users/rivigo/mswasth/crm/src/App.tsx",[],["116","117"],"/Users/rivigo/mswasth/crm/src/store/index.ts",[],"/Users/rivigo/mswasth/crm/src/store/rootReducer.ts",[],"/Users/rivigo/mswasth/crm/src/containers/login/reducer.ts",[],"/Users/rivigo/mswasth/crm/src/containers/login/actionType.enum.ts",[],"/Users/rivigo/mswasth/crm/src/store/initialState.ts",[],"/Users/rivigo/mswasth/crm/src/containers/login/index.tsx",[],"/Users/rivigo/mswasth/crm/src/containers/login/actions.ts",[],"/Users/rivigo/mswasth/crm/src/containers/Login/reducer.ts",[],"/Users/rivigo/mswasth/crm/src/containers/Login/index.tsx",["118"],"/Users/rivigo/mswasth/crm/src/containers/Login/actionType.enum.ts",[],"/Users/rivigo/mswasth/crm/src/containers/Login/actions.ts",[],"/Users/rivigo/mswasth/crm/src/containers/PatientRecords/index.tsx",["119","120","121"],"/Users/rivigo/mswasth/crm/src/containers/PatientRecords/actions.ts",["122"],"import ACTION_TYPES from \"./actionType.enum\"\nimport DataService from \"../../services/data.service\"\nimport cookieService from \"../../services/cookie.service\"\n\nconst dummyPatients = [\n  {\n    name: 'Mrs. Shashi',\n    mobileNumber: '9823722332',\n    lastCheckupTimestamp: 1611426600000,\n    nextCheckupTimestamp: 1612377000000\n  },\n  {\n    name: 'Mr. Akash',\n    mobileNumber: '9823722332',\n    lastCheckupTimestamp: 1611426600000,\n    nextCheckupTimestamp: 1612463400000\n  },\n  {\n    name: 'Mrs. Virali',\n    mobileNumber: '9823722332',\n    lastCheckupTimestamp: 1611513000000,\n    nextCheckupTimestamp: 1612463400000\n  },\n  {\n    name: 'Mr. Sanjay',\n    mobileNumber: '9823722332',\n    lastCheckupTimestamp: 1611513000000,\n    nextCheckupTimestamp: 1612549800000\n  },\n  {\n    name: 'Mrs. Akriti',\n    mobileNumber: '9823722332',\n    lastCheckupTimestamp: 1611685800000,\n    nextCheckupTimestamp: 1612549800000\n  },\n  {\n    name: 'Mr. Shashi',\n    mobileNumber: '9823722332',\n    lastCheckupTimestamp: 1611685800000,\n    nextCheckupTimestamp: 1612722600000\n  },\n  {\n    name: 'Mr. Gulati',\n    mobileNumber: '9823722332',\n    lastCheckupTimestamp: 1611772200000,\n    nextCheckupTimestamp: 1612722600000\n  },\n  {\n    name: 'Mrs. Khambiya',\n    mobileNumber: '9823722332',\n    lastCheckupTimestamp: 1611772200000,\n    nextCheckupTimestamp: 1612895400000\n  },\n  {\n    name: 'Mr. Amol',\n    mobileNumber: '9823722332',\n    lastCheckupTimestamp: 1611858600000,\n    nextCheckupTimestamp: 1612895400000\n  },\n  {\n    name: 'Mrs. Shivani',\n    mobileNumber: '9823722332',\n    lastCheckupTimestamp: 1611858600000,\n    nextCheckupTimestamp: 1612981800000\n  },\n  {\n    name: 'Mrs. Shivani',\n    mobileNumber: '9823722332',\n    lastCheckupTimestamp: 1611858600000,\n    nextCheckupTimestamp: 1612981800000\n  }\n]\n\nconst dummyPatientRecords = {\n  list: dummyPatients,\n  pagination: {\n    totalPages: 2,\n    pageNumber: 1,\n    pageSize: 10\n  }\n}\n\nexport const getPatientRecords = (pagination: any) => {\n  return async (dispatch: Function) => {\n    let loggedInUser = await DataService.getLoggedInUserFromStorage();\n    if (loggedInUser) {\n      DataService.get(\"getPatientRecords\", loggedInUser, {}, { fake: false, data: dummyPatientRecords }).then((response: any) => {\n        if (response && response.data) {\n          dispatch({\n            type: ACTION_TYPES.PATIENT_RECORDS_SUCCESS,\n            data: response.data\n          })\n        }\n      }) \n    } else {\n    }\n  }\n}","/Users/rivigo/mswasth/crm/src/containers/PatientRecords/actionType.enum.ts",[],"/Users/rivigo/mswasth/crm/src/services/data.service.ts",["123","124","125"],"import EventService from \"./event.service\"\nimport CookieService from \"./cookie.service\"\nimport { getApiContext } from \"../config/app.config\"\n\nclass HttpService {\n  private static instance: HttpService\n\n  /**\n   * The Singleton's constructor should always be private to prevent direct\n   * construction calls with the `new` operator.\n   */\n  private constructor() {\n    this.initConfigs()\n  }\n\n  /**\n   * The static method that controls the access to the singleton instance.\n   *\n   * This implementation let you subclass the Singleton class while keeping\n   * just one instance of each subclass around.\n   */\n  public static getInstance(): HttpService {\n    if (!HttpService.instance) {\n      HttpService.instance = new HttpService()\n    }\n\n    return HttpService.instance\n  }\n  globalOptions: any = {}\n  CACHE = {}\n  API_CONTEXT = getApiContext()\n\n  /**\n   * List of urls to be used in the whole app. Hit api with name of url. Not the exact url.\n   * @type [{string:string}]\n   */\n  static urlMap: any = {\n    login: \"/doc_login/{username}/{password}/\",\n    logout: \"/user/logout\",\n    getPatientRecords: \"view_patient_records/{username}/{password}/\"\n  }\n\n  /**\n   * Initialize configurations for http client of application\n   */\n  initConfigs() {\n    this.globalOptions = {\n      mode: \"cors\", // no-cors, cors, *same-origin\n      headers: {\n        accept: \"application/json\",\n        \"content-type\": \"application/json\",\n      },\n    }\n    this.API_CONTEXT = getApiContext();\n  }\n\n  async getAccessTokenFromStorage() {\n    let value:any\n    try {\n      value = await CookieService.get(this.API_CONTEXT)\n    } catch (e) {\n      console.error(\"DataService\", e)\n    }\n    return value ? value.access_token : null\n  }\n\n  async getLoggedInUserFromStorage() {\n    let value:any\n    try {\n      value = await CookieService.get(this.API_CONTEXT)\n    } catch (e) {\n      console.error(\"DataService\", e)\n    }\n    return value && value.user && !this.isObjectEmpty(value.user) ? JSON.parse(value.user) : null\n  }\n\n  async logoutUser() {\n    await CookieService.set('user', null);\n  }\n\n  async getGlobalOptions() {\n    const authToken = await this.getAccessTokenFromStorage()\n    if (authToken) {\n      return {\n        ...this.globalOptions,\n        headers: {\n          ...this.globalOptions.headers,\n          authorization: \"Bearer \" + (authToken || \"\"),\n        },\n      }\n    } else {\n      return this.globalOptions\n    }\n  }\n\n  /**\n   * Creates a url query param string out of key value pairs provided\n   * @param {key: valuePair}\n   * @returns {string}\n   * encodeQueryData({name: 'promil',age:'100'}) => &name=promil&age=100\n   */\n  encodeQueryData(data: any) {\n    const ret = []\n    for (const d in data) {\n      if (data[d] !== undefined && data[d] !== null) {\n        ret.push(encodeURIComponent(d) + \"=\" + encodeURIComponent(data[d]))\n      }\n    }\n    return ret.length ? \"?\" + ret.join(\"&\") : \"\"\n  }\n\n  /**\n   *\n   * @param {string} url:  Name of url in this.urlMap\n   * @param config  [name: valuePair]\n   * @returns {string}\n   * urlMap= {deleteUser: '/user/{userId}/delete}; prepare('deleteUser',{userId: 10}) => /user/10/delete\n   */\n  prepare(url: string, config: any) {\n    url = HttpService.urlMap[url] || url\n    for (const i in config) {\n      if (config.hasOwnProperty(i)) {\n        url = url.replace(\"{\" + i + \"}\", config[i])\n      }\n    }\n    return url\n  }\n\n  /**\n   * Merge passed query params with global query params . Create a queryParam string from final object\n   * @param queryParams\n   * @returns {string}\n   */\n  createQueryParams(queryParams: any) {\n    queryParams = { ...queryParams}\n    return this.encodeQueryData(queryParams)\n  }\n\n  /**\n   * Generate an absolute path out of\n   * @param {string} url:  name of url in urlMap\n   * @param apiParams:     an object containing all api params\n   * @param queryParams    an object containing all query params\n   * @returns {string}     final absolute path => http://api.com/name?name=promil\n   */\n  getAbsoluteApiPath(\n    url:string,\n    apiParams:any,\n    queryParams:any,\n    config:any = {\n      onSocket: false,\n    }\n  ) {\n    const absolutePathTest = new RegExp(\"^(?:[a-z]+:)?//\", \"i\")\n\n    if (absolutePathTest.test(url)) {\n      return this.prepare(url, apiParams) + this.createQueryParams(queryParams)\n    } else if (absolutePathTest.test(HttpService.urlMap[url])) {\n      return (\n        this.prepare(HttpService.urlMap[url], apiParams) +\n        this.createQueryParams(queryParams)\n      )\n    } else {\n      let apiBase = \"\"\n      url = this.prepare(url, apiParams)\n      apiBase = this.API_CONTEXT\n      return apiBase + url + this.createQueryParams(queryParams)\n    }\n  }\n\n  /**\n   * A helper wrapper over angular get method.\n   * @param {string} url :  name of path in urlMap\n   * @param apiParams:   {'string': value}\n   * @param queryParams  {[name: string]: string}\n   * @param config   { 'cache': true, 'fake' ?: boolean, 'data'?: any }  whether response to this api should cached\n   * @returns {Promise<ArrayBuffer>}\n   */\n  async get(url: string, apiParams: any, queryParams: any, config: any = {}) {\n    // queryParams.time = new Date().getTime();\n    const globalOptions = await this.getGlobalOptions()\n    const options = { ...globalOptions, ...config }\n    const parsedUrl = this.getAbsoluteApiPath(\n      url,\n      apiParams,\n      queryParams,\n      config\n    )\n    if (config && config.fake) {\n      return this.getFakeResponse(\n        config.data,\n        config.timeout || 2000,\n        config.shouldReject\n      )\n    }\n    return this._get(parsedUrl, options)\n  }\n\n  /**\n   * Internal method. Make a get http call. parse response. handle errors.\n   * @param url\n   * @param options\n   * @returns {Promise<never | ArrayBuffer>}\n   * @\n   */\n  _get(url: string, options: any) {\n    const optionsToSubmit = {\n      method: \"GET\", // *GET, POST, PUT, DELETE, etc.\n      ...options,\n    }\n    return fetch(url, optionsToSubmit)\n      .then(res => {\n        return res\n          .json()\n          .then(json => {\n            return {\n              extractedResp: json,\n              res,\n            }\n          })\n          .then(({ extractedResp, res }) => {\n            return this.extractData(res, options, extractedResp)\n          })\n          .catch(err => {\n            return this.handleError(err, options)\n          })\n      })\n      .catch(err => {\n        try {\n          return this.handleError(err, options)\n        } catch (e) {\n          console.error(e)\n        }\n      })\n  }\n\n  /**\n   * Wrapper function over angular post method\n   * @param {string} url\n   * @param apiParams\n   * @param body\n   * @param config\n   * @returns {Promise<never | ArrayBuffer>}\n   */\n  async post(url:string, apiParams:any, body:any, config:any) {\n    const formData = new FormData()\n    const isUploadingAFile = config && config.fileUpload === true\n    const parsedUrl = this.getAbsoluteApiPath(url, apiParams, {}, config)\n    const globalOptions = await this.getGlobalOptions()\n    const options = { ...globalOptions, ...config }\n\n    if (options && options.fake) {\n      return this.getFakeResponse(\n        options.data,\n        options.timeout || 2000,\n        options.shouldReject\n      )\n    }\n\n    if (isUploadingAFile) {\n      // browser will automatically detect content type and set appropriate multipart boundary\n      delete options.headers[\"Content-Type\"]\n      for (const key in body) {\n        if (Object.hasOwnProperty.call(body, key)) {\n          formData.append(key, body[key])\n        }\n      }\n    }\n\n    return fetch(parsedUrl, {\n      method: \"POST\", // *GET, POST, PUT, DELETE, etc.\n      ...options,\n      body: isUploadingAFile ? formData : JSON.stringify(body), // body data type must match \"Content-Type\" header\n    })\n      .then(res => {\n        return res.json().then(json => {\n          return {\n            extractedResp: json,\n            res,\n          }\n        })\n      })\n      .then(({ extractedResp, res }) =>\n        this.extractData(res, options, extractedResp)\n      )\n      .catch(err => {\n        return this.handleError(err, options)\n      })\n  }\n\n  /**\n   * Wrapper function over angular put method\n   * @param {string} url\n   * @param apiParams\n   * @param body\n   * @param config\n   * @returns {Promise<never | ArrayBuffer>}\n   */\n  async put(url:any, apiParams:any, body:any, config?:any) {\n    // queryParams.time = new Date().getTime();\n    const globalOptions = await this.getGlobalOptions()\n    const options = { ...globalOptions, ...config }\n    const parsedUrl = this.getAbsoluteApiPath(url, apiParams, {}, config)\n    return fetch(parsedUrl, {\n      method: \"PUT\", // *GET, POST, PUT, DELETE, etc.\n      ...options,\n      body: JSON.stringify(body),\n    })\n      .then(res => {\n        return res.json().then(json => {\n          return {\n            extractedResp: json,\n            res,\n          }\n        })\n      })\n      .then(({ extractedResp, res }) =>\n        this.extractData(res, options, extractedResp)\n      )\n      .catch(err => {\n        return this.handleError(err, options)\n      })\n  }\n\n  /**\n   * Wrapper function over angular put method\n   * @param {string} url\n   * @param apiParams\n   * @param body\n   * @param config\n   * @returns {Promise<never | ArrayBuffer>}\n   */\n  patch(url:any, apiParams:any, body:any, config:any) {\n    const parsedUrl = this.getAbsoluteApiPath(url, apiParams, {}, config)\n    const options = Object.assign({}, this.getGlobalOptions(), ...config)\n    return fetch(parsedUrl, {\n      method: \"PATCH\", // *GET, POST, PUT, DELETE, etc.\n      ...options,\n      body: JSON.stringify(body),\n    })\n      .then(res => {\n        return res.json().then(json => {\n          return {\n            extractedResp: json,\n            res,\n          }\n        })\n      })\n      .then(({ extractedResp, res }) =>\n        this.extractData(res, options, extractedResp)\n      )\n      .catch(err => {\n        return this.handleError(err, options)\n      })\n  }\n\n  async delete(url:any, apiParams:any, config:any) {\n    const globalOptions = await this.getGlobalOptions()\n    const parsedUrl = this.getAbsoluteApiPath(url, apiParams, {}, config)\n    const options = { ...globalOptions, ...config }\n    return fetch(parsedUrl, {\n      method: \"DELETE\", // *GET, POST, PUT, DELETE, etc.\n      ...options,\n    })\n      .then(res => {\n        return res.json().then(json => {\n          return {\n            extractedResp: json,\n            res,\n          }\n        })\n      })\n      .then(({ extractedResp, res }) =>\n        this.extractData(res, options, extractedResp)\n      )\n      .catch(err => {\n        return this.handleError(err, options)\n      })\n  }\n\n  /**\n   * Handle http response received. Code 0 means successful response. Any other code means error in response\n   * @param res\n   * @param config\n   * @returns {any}\n   */\n\n  extractData(originalResponse:any, config:any, extractedResponse:any) {\n    config = config || {}\n\n    /** workaround for non rest api, ONLY DEMO PURPOSE */\n    return extractedResponse;\n    /** workaround for non rest api, ONLY DEMO PURPOSE */\n\n    if (originalResponse && originalResponse.status >= 400) {\n      /**\n       * Anything other then code 0 throws an error. Will be handled by handleError method\n       */\n      throw { ...extractedResponse, status: originalResponse.status }\n    } else if (extractedResponse.code !== 0) {\n      throw { ...extractedResponse, status: originalResponse.status }\n    } else {\n      let canShowMessage = false\n      if (\n        Object.hasOwnProperty.call(config, \"showMessage\") &&\n        config.showMessage === true\n      ) {\n        canShowMessage = true\n      }\n\n      if (canShowMessage && extractedResponse.message) {\n        this.openSnackBar(\"\", extractedResponse.message, \"success\")\n      }\n      return extractedResponse\n    }\n  }\n\n  async handleError(error:any, config:any) {\n    try {\n      config = config || {}\n\n      /**\n       * By default 401 error redirects to login page. But if already on login page, use this flag to prevent redirect loop\n       */\n      if (!config.hasOwnProperty(\"redirectOn401\")) {\n        config.redirectOn401 = true\n      }\n\n      const statusText = error.statusText,\n        errorMessage = error.body\n\n      let canShowMessage = true\n      if (\n        Object.hasOwnProperty.call(config, \"showMessage\") &&\n        config.showMessage === false\n      ) {\n        canShowMessage = false\n      }\n\n      if (canShowMessage) {\n        this.openSnackBar(\n          statusText,\n          errorMessage ||\n            error.message ||\n            error.status ||\n            \"Something went wrong!\",\n          \"error\"\n        )\n      }\n\n      if (error.status === 401 && config.redirectOn401) {\n        await this.triggerLogoutAction()\n      }\n    } catch (e) {\n      console.error(e)\n    }\n  }\n\n  async triggerLogoutAction() {\n    try {\n      EventService.dispatch(\"LOGOUT\", {})\n    } catch (e) {\n      console.error(e)\n    }\n  }\n\n  getMessageFromList(error:any) {\n    const list = error.validationErrors || error.validationErrorList || []\n    if (list && list.length) {\n      return list[0].message\n    } else {\n      return \"\"\n    }\n  }\n\n  /**\n   * A wrapper over angular toast method to show success and error toasts to users\n   * @param {...messageKeys}\n   * @param config\n   */\n  openSnackBar(title:string, message:string, variant:any) {\n    EventService.dispatch(\"toast\", {\n      title,\n      message,\n      variant,\n    })\n  }\n\n  getFakeResponse(data:any, timeout: number, shouldReject:boolean) {\n    return new Promise((resolve, reject) => {\n      window.setTimeout(() => {\n        if (typeof shouldReject === \"boolean\" && !shouldReject) {\n          reject(data)\n        } else {\n          resolve(data)\n        }\n      }, timeout)\n    })\n  }\n\n  isObjectEmpty = (empty: any) => {\n    return Object.keys(empty).length === 0 && empty.constructor === Object\n  }\n}\n\nconst DataService = HttpService.getInstance()\nexport default DataService\n","/Users/rivigo/mswasth/crm/src/services/event.service.ts",[],"/Users/rivigo/mswasth/crm/src/services/cookie.service.ts",[],"/Users/rivigo/mswasth/crm/src/config/app.config.ts",[],"/Users/rivigo/mswasth/crm/src/containers/PatientRecords/reducer.ts",[],"/Users/rivigo/mswasth/crm/src/containers/Landing/index.tsx",[],"/Users/rivigo/mswasth/crm/src/components/Header/index.tsx",[],"/Users/rivigo/mswasth/crm/src/components/ProtectedRoute.tsx",[],"/Users/rivigo/mswasth/crm/src/components/Sidebar/index.tsx",[],{"ruleId":"126","replacedBy":"127"},{"ruleId":"128","replacedBy":"129"},{"ruleId":"126","replacedBy":"130"},{"ruleId":"128","replacedBy":"131"},{"ruleId":"132","severity":1,"message":"133","line":3,"column":20,"nodeType":"134","messageId":"135","endLine":3,"endColumn":30},{"ruleId":"132","severity":1,"message":"136","line":9,"column":8,"nodeType":"134","messageId":"135","endLine":9,"endColumn":15},{"ruleId":"132","severity":1,"message":"137","line":39,"column":19,"nodeType":"134","messageId":"135","endLine":39,"endColumn":30},{"ruleId":"132","severity":1,"message":"138","line":39,"column":32,"nodeType":"134","messageId":"135","endLine":39,"endColumn":42},{"ruleId":"132","severity":1,"message":"139","line":3,"column":8,"nodeType":"134","messageId":"135","endLine":3,"endColumn":21},{"ruleId":"140","severity":1,"message":"141","line":395,"column":5,"nodeType":"142","messageId":"143","endLine":415,"endColumn":6},{"ruleId":"144","severity":1,"message":"145","line":399,"column":7,"nodeType":"146","messageId":"147","endLine":399,"endColumn":70},{"ruleId":"144","severity":1,"message":"145","line":401,"column":7,"nodeType":"146","messageId":"147","endLine":401,"endColumn":70},"no-native-reassign",["148"],"no-negated-in-lhs",["149"],["148"],["149"],"@typescript-eslint/no-unused-vars","'withRouter' is defined but never used.","Identifier","unusedVar","'Sidebar' is defined but never used.","'patientList' is assigned a value but never used.","'pagination' is assigned a value but never used.","'cookieService' is defined but never used.","no-unreachable","Unreachable code.","IfStatement","unreachableCode","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","no-global-assign","no-unsafe-negation"]